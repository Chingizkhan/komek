package v1

import (
	"errors"
	"golang.org/x/oauth2"
	"komek/internal/service/oauth"
	"komek/internal/service/oauth/oidc"
	"komek/pkg/cookies"
	"komek/pkg/http/api_util"
	"komek/pkg/logger"
	"komek/pkg/state"
	"log"
	"net/http"
)

func (h *Handler) callback(secret []byte) http.HandlerFunc {
	fn := func(w http.ResponseWriter, r *http.Request) {
		var req CallbackRequest
		err := req.Validate(r)
		if err != nil {
			api_util.RenderErrorResponse(w, err.Error(), http.StatusBadRequest)
			return
		}

		cookieState, err := cookies.ReadSigned(r, oidc.CookieName, secret)
		if err != nil {
			h.l.Error("cookie read", logger.Err(err))
			return
		}

		if cookieState != r.FormValue("state") {
			api_util.RenderErrorResponse(w, "state is not generated by this Client", http.StatusOK)
			return
		}

		log.Println("req.Code:", req.Code)
		token, err := oauth.Config.Exchange(r.Context(), req.Code)
		if err != nil {
			h.l.Error("callback", logger.KV("couldn't get token", err.Error()))
			//http.Redirect(w, r, "/", http.StatusTemporaryRedirect)
			return
		}

		h.l.Info("CALLBACK EXECUTED", logger.KV("access_token", token.AccessToken), logger.KV("refresh_token", token.RefreshToken))

		processCookies(w, token)
		introspectResponse, err := h.oauthServerClient.Introspect(token.AccessToken)
		if err != nil {
			return
		}

		log.Println("client_id", introspectResponse.ClientID)
		log.Println("active", introspectResponse.Active)

		//http.Redirect(w, r, "http://localhost:3000", http.StatusTemporaryRedirect)
	}

	return fn
}

func processCookies(w http.ResponseWriter, token *oauth2.Token) {
	cookieAccess := &http.Cookie{
		Name:     "Access-Token",
		Value:    token.AccessToken,
		Secure:   false,
		HttpOnly: false,
		SameSite: http.SameSiteLaxMode,
	}
	cookieRefresh := &http.Cookie{
		Name:     "Refresh-Token",
		Value:    token.RefreshToken,
		Secure:   false,
		HttpOnly: false,
		SameSite: http.SameSiteLaxMode,
	}
	http.SetCookie(w, cookieAccess)
	http.SetCookie(w, cookieRefresh)
}

type (
	CallbackRequest struct {
		Code  string
		State state.State
	}
)

func (r *CallbackRequest) Validate(req *http.Request) error {
	code := req.FormValue("code")
	st := req.FormValue("state")

	if code == "" {
		return errors.New("authorization code is empty")
	}
	if st == "" {
		return errors.New("state is empty")
	}

	stateModel, err := state.New(st)
	if err != nil {
		return err
	}

	r.Code = code
	r.State = stateModel

	return nil
}
